This tutorial demonstrates how you can apply HLS attributes to members
variables of a struct in order to control the memory systems generated by the
compiler.

This tutorial is divided into the following parts:

- Part 1 guides you on the basic usage of attributes on member variables of a
  struct.
- Part 2 explains how arrays of structs interact with attributes on member
  variables.
- Part 3 describes the interaction between attributes applied to a struct
  instantiantion and attributes applied to member variables.

For more information about memory attributes, see Table "Intel HLS Compiler
Component Memory Attributes" in the Intel HLS Compiler Reference Manual.

Run the Makefile and, for each of the [ProjectFolder] directories that follow,
navigate to the High Level Design report (located in
[ProjectFolder]/reports/report.html) in the following order:

1- attr_ok.prj
  Explanation:
  A struct called State is defined with multiple member variables, and an
  instantiation of this struct is declared inside a component.  The first
  member variable, named "register_attr", is an array that would normally be
  implemented as a memory. However, because it contains the attribute
  hls_register, it becomes a register.

  Open the High Level Design report, click "View reports..."  and navigate to
  "Component Memory Viewer". Under "Memory List", click "attr_ok".

  There is no memory called "register_attr".

  The second member variable, named "register_no_attr", does not contain any
  attributes.  Because it is 32-bit integer, it is also implemented as a
  register. In the report, there is no memory called "register_no_attr" either.

  The third member variable, named "memory", contains the hls_memory attribute.
  As such, it is implemented as a memory and therefore can be found in the
  report. Look for a memory named "memory".

  The fourth member variable, named "small_memory", would normally be
  implemented as a register, because it is only 32 bits wide. However, since it
  has the hls_memory attribute, it has been implemented as a memory. Look for a
  memory called "small_memory" in the report.

2- array_prevails.prj
  Explanation:
  An array of State structs is declared. Because it is an array, it becomes a
  single memory. In other words, the attributes applied to the struct member
  variables are ignored by the compiler. A warning was issued about about this.

  Open the High Level Design report, click "View reports..."  and navigate to
  "Component Memory Viewer". Under "Memory List", click
  "array_prevails".

  There is a single memory called "MyStateArray".

3- outer_prevails.prj
  Explanation:
  A variable of type State structs is instantiated with an hls_memory
  attribute. Because there is an attribute on the struct instantiation, the
  attributes applied to the struct member variables are ignored by the
  compiler. A warning was issued about about this.

  Open the High Level Design report, click "View reports..."  and navigate to
  "Component Memory Viewer". Under "Memory List", click
  "outer_prevails".

  There is a single memory called "MyState". This single memory is a result of
  the hls_memory attribute being applied to MyState.
