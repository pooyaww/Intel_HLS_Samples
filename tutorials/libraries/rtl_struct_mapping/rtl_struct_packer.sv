`timescale 1 ps / 1 ps

// This module performs conversion between unpacked and packed structures
// that are otherwise equivalent, namely the struct_a and packed_struct_a 
// types.
//
// Most of the Verilog code has been generated by Part 1 of the tutorial -
// specifically the input, output, and local signal declarations and the
// code that breaks out fields of the input structure and assembles the
// packed structure. 
//
// Only the processing logic has been written by hand - and in this case
// it is just an association between input and output fields.  
//
// The module name incorporates the struct type name to prevent clashes with
// the names of other RTL modules that may be present in the user's design.


// These typedefs have been copied from the interface_structs.v file that
// was generated by compiling the C model as a component. 
// Unlike C++ struct definitions, the first-named fields occupy the high-
// order bits of the wide signal that results from flattening a struct. 
// The first-declared fields of the C++ struct in your HLS program 
// occupy the least-significant bits of the wide input to the RTL-
// -based function - so the C++ and Verilog declarations do match up in 
// practice! 

typedef struct packed {
 logic [63:0] field_7_int64_t;
 logic [31:0] __padding$208;
 logic [8:0] [15:0] field_6_int16_t_array;
 logic [7:0] __padding$192;
 logic [7:0] field_5_uint8_t;
 logic [63:0] field_4_double;
 logic [55:0] __padding$64;
 logic [7:0] field_3_char;
 logic [31:0] field_2_int32_t;
 logic [23:0] __padding$0;
 logic [7:0] field_1_bool;
} struct_struct_a;

typedef struct packed {
 logic [63:0] field_7_int64_t;
 logic [8:0] [15:0] field_6_int16_t_array;
 logic [7:0] field_5_uint8_t;
 logic [63:0] field_4_double;
 logic [7:0] field_3_char;
 logic [31:0] field_2_int32_t;
 logic [7:0] field_1_bool;
} struct_packed_struct_a;

// end of declarations from interface_structs.v

module rtl_struct_a_packer (
		input  wire         clock,      
		input  wire         resetn,     
		input  wire         ivalid, //   call.valid
		output wire         oready, //       .ready_out
		output wire         ovalid, // return.valid
		input  wire         iready, //       .ready in
		output wire [$bits(struct_packed_struct_a)-1:0] return_value, 
		input  wire [$bits(struct_struct_a)-1:0]        struct_a_in   
	);

  struct_struct_a        datain;
  struct_packed_struct_a dataout;

  // handshake outputs are tied high
  assign  ovalid = 1'b1;
  assign  oready = 1'b1;
  // clk, ivalid, iready, resetn are ignored

  assign datain = struct_a_in;

  assign dataout.field_1_bool          = datain.field_1_bool;
  assign dataout.field_2_int32_t       = datain.field_2_int32_t;
  assign dataout.field_3_char          = datain.field_3_char;
  assign dataout.field_4_double        = datain.field_4_double;
  assign dataout.field_5_uint8_t       = datain.field_5_uint8_t;
  assign dataout.field_6_int16_t_array = datain.field_6_int16_t_array;
  assign dataout.field_7_int64_t       = datain.field_7_int64_t;

  assign return_value = dataout;

endmodule



