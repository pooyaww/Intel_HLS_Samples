<!-- rtl_struct_packer.xml
     In this file the calling interface to the RTL modules is described to the compiler.
     This module provides a set of functions that illustrate how C and C++ structs are 
     mapped to arguments of RTL-based functions. -->

<RTL_SPEC>

  <!-- 'name' is how this function will be called from an OpenCL kernel.
       'module' is the top-level HDL module name that implements the function. -->
  <FUNCTION name="rtl_struct_a_packer" module="rtl_struct_a_packer">
    <ATTRIBUTES>
      <!-- This section provides information that the compiler needs to integrate the RTL module 
           into the computational pipeline that it is building. In this case the RTL does not contain
           registers and therefore cannot stall the pipeline or handle stall signals from the 
           data destination (e.g. stalls due to memory contention). The compiler must therefore build
           stall-handling logic around the RTL). 
           Since there are no registers in the RTL, it has zero latency.
           The function doe not have state; the compiler may use this information to better
           optimize code that uses the function. -->
      <IS_STALL_FREE value="yes"/>
      <IS_FIXED_LATENCY value="yes"/>
      <EXPECTED_LATENCY value="0"/>
      <HAS_SIDE_EFFECTS value="no"/>
      <!-- Set to "yes" to allow multiple instances of this function to be merged by the compiler. -->
      <ALLOW_MERGING value="yes"/>
    </ATTRIBUTES>
    <INTERFACE>
      <!-- although the RTL has no registers, clock and reset inputs must still be specified -->
      <AVALON port="clock" type="clock"/>
      <AVALON port="resetn" type="resetn"/>
      <!-- similarly the RTL module must provide handshake signals even when it is not stallable -->
      <AVALON port="ivalid" type="ivalid"/>
      <AVALON port="iready" type="iready"/>
      <AVALON port="ovalid" type="ovalid"/>
      <AVALON port="oready" type="oready"/>
      <!-- call arguments are mapped onto the input ports - the first INPUT specifies the name of the
           RTL port to which the first call argument will be connected, and so on. 
           The widths of the struct-type input and result have been determined by examining the top
           level struct_packer.v file that was generated by compiling the C model as a component. -->
      <INPUT  port="struct_a_in" width="448"/>
      <!-- the single output port provides the result of the function call -->
      <OUTPUT port="return_value" width="328"/>
    </INTERFACE>
    <REQUIREMENTS>
      <FILE name="rtl_struct_packer.sv" />
    </REQUIREMENTS>
  </FUNCTION>

</RTL_SPEC>

