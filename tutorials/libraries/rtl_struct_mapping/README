Introduction

This tutorial demonstrates how to obtain the mapping of struct fields to signal bits that
the Intel High Level Synthesis compiler employs when a struct is passed to or returned
from an RTL-based function. You can use this information to declare corresponding
SystemVerilog struct types and use them in your RTL code.   

Before studying this tutorial, you should be familiar with the RTL library development flow. 
The RTL library development flow is explained in the Intel High Level Synthesis Compiler 
Reference Manual. For a quick introduction to the flow, refer to the basic_rtl_library_flow 
tutorial.


RTL representation of struct datatypes

When you pass a structure-type value to an RTL-based function, the structure is mapped to
a single input signal of the RTL module that implements the function. You can write code in 
the RTL module that breaks out the fields of the struct into separate signals, provided 
that you can determine the in-memory layout of the struct. 

The in-memory layout of a struct depends on on the size, order, and alignment of its fields, 
and on whether the struct has been specified to be packed. 

The idea that struct packing is undesirable is a result of the fixed architecture of CPU 
hardware. When writing HLS code for synthesis to FPGA hardware, using packed structs 
typically saves on-chip resources without any performance penalty. 

When you use packed structs as arguments to your RTL-based functions you can determine the 
struct layout as follows:  fields start on byte boundaries and the first-declared fields 
occupy the lowest bits of the wide input signal that corresponds to the struct argument. 

Structs that are not packed might have padding added by the compiler. You can identify
the layout of the signal corresponding to the struct argument or return value, based on
component interface specification generated by the HLS compiler. 

For more information, see the "Mapping HLS data types to RTL signals" section of the Intel
High Level Synthesis Compiler Reference Manual. 


Compiler-generated RTL struct declarations

When you compile an HLS component that is declared as extern "C", the Intel High Level Synthesis 
Compiler generates Verilog declarations for struct types that are arguments to or return values 
of the component function. 
These declarations can be found in 
  <project dir>/components/<component_name>/interface_structs.v

If the emulation models of your RTL-based functions do not use host-only language features 
or library functions, you can obtain their interface struct declarations by performing an 
FPGA-only compilation of the emulation models and specifying that these functions should be 
packaged as components. 

In this tutorial, the RTL-based struct packing function is called rtl_struct_a_packer, and 
the emulation models are found in the file rtl_struct_packer_emu_models.cpp. Use this 
command to obtain the interface struct declarations:

i++ -march="Arria10" rtl_struct_packer_emu_models.cpp --component rtl_struct_a_packer --simulator none

The sole purpose of this compilation is to obtain the interface_structs.v file, which can
be found in a.prj/components/rtl_struct_a_packer/interface_structs.v

If your emulation models do contain code that cannot be compiled for FPGA, you can comment 
out the code in the bodies of the emulation model functions before you perform this special
compilation. 

You can now incorporate the compiler-generated SystemVerilog struct types in your own
RTL code.  


Sample RTL functions

The example used in this tutorial is an RTL-based function that copies the fields of an
unpacked struct into into an equivalent packed structure - this rtl_struct_packer.sv 
file uses the interface declarations that the compiler generated from the emulation model 
file. 


Notes

If you use ac_int fields in a struct type that is the return value of an RTL-based function, 
the compiler warns you that the datatype might not be C-compatible. For example, 
    warning: 'rtl_struct_a_packer' has C-linkage specified, but returns user-defined type 
    'packed_struct_a' which is incompatible with C
You can safely ignore these warnings. 

Each ac_int field is implemented as a multi-byte slice of the structure, with a slice width
determined by the smallest integer type that can contain values of that ac_int datatype.


This tutorial requires the following tools to be installed:
  - Intel HLS Compiler
  - ModelSim

To run this tutorial:
  - On Linux run "make"
  - On Windows run "build"
